<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Interactive Scene + Import & Export</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #ui-container, #import-ui, #visibility-container {
      position: absolute; left: 10px; z-index: 10;
      background: rgba(255,255,255,0.9); padding: 10px;
      border-radius: 4px; font-family: sans-serif;
      font-size: 14px; max-width: 240px;
    }
    #ui-container { top: 10px; }
    #import-ui { display: none; }
    #visibility-container { bottom: 10px; }
    #objectList div { display: flex; align-items: center; margin-bottom: 4px; }
    #objectList input[type="checkbox"] { margin-right: 6px; }
    #objectList span { flex: 1; cursor: pointer; }
  </style>
</head>
<body>
  <div id="ui-container">
    <div>
      <label for="modeSelect">Mode:</label>
      <select id="modeSelect">
        <option value="draw" selected>Create</option>
        <option value="edit">Edit</option>
        <option value="import">Import</option>
      </select>
    </div>
    <div id="draw-ui" style="margin-top:6px;">
      <label for="height">Height:</label>
      <input id="height" type="number" step="0.1" value="1"><br>
      <label for="scale">Scale:</label>
      <input id="scale" type="number" step="0.1" value="1">
      <select id="unitSelect">
        <option value="meters">Meters</option>
        <option value="feet" selected>Feet</option>
      </select>
    </div>
    <div id="edit-ui" style="margin-top:6px; display:none;">
      <label for="transformMode">Transform:</label>
      <select id="transformMode">
        <option value="translate" selected>Move</option>
        <option value="rotate">Rotate</option>
      </select>
      <button id="snapFloor" style="margin-left:8px;">Return to Floor</button>
    </div>
    <button id="exportScene" style="margin-top:10px;">Export Scene (OBJ)</button>
    <div style="margin-top:6px; font-size:12px; color:#333;">
      Create: drag • Edit: select/move/rotate • Import: place • Export scene
    </div>
    <button id="uploadModel" style="margin-top:6px;">Upload Model</button>
    <input id="modelInput" type="file" accept=".gltf,.glb,.obj" style="display:none;">
    <div id="uploadStatus" style="font-size:12px; color:#555; margin-top:4px;">No model selected</div>
  </div>
  <div id="import-ui">
    <button id="addFloor">Add Floor</button>
    <button id="addWall">Add Wall</button>
    <button id="addWallThick">Add Wall Think</button>
  </div>
  <div id="visibility-container">
    <strong>Visibility</strong>
    <div id="objectList"></div>
  </div>
  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.155.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.155.0/examples/jsm/loaders/GLTFLoader';
    import { OBJLoader }  from 'https://esm.sh/three@0.155.0/examples/jsm/loaders/OBJLoader';
    import { OrbitControls } from 'https://esm.sh/three@0.155.0/examples/jsm/controls/OrbitControls';
    import { TransformControls } from 'https://esm.sh/three@0.155.0/examples/jsm/controls/TransformControls';
    import { OBJExporter } from 'https://esm.sh/three@0.155.0/examples/jsm/exporters/OBJExporter.js';

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(5,5,5); camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Grid & Lights
    const grid = new THREE.GridHelper(20,20);
    grid.receiveShadow=true; scene.add(grid);
    scene.add(new THREE.AmbientLight(0xffffff,0.5));
    const dirLight=new THREE.DirectionalLight(0xffffff,0.8);
    dirLight.position.set(5,10,7); dirLight.castShadow=true; scene.add(dirLight);

    // Controls
    const controls=new OrbitControls(camera,renderer.domElement);
    controls.enableDamping=true; controls.dampingFactor=0.05;
    controls.enablePan=true; controls.enableZoom=true;
    controls.mouseButtons={LEFT:THREE.MOUSE.NONE,MIDDLE:THREE.MOUSE.ROTATE,RIGHT:THREE.MOUSE.PAN};
    window.addEventListener('keydown',e=>{if(e.key==='Shift')controls.mouseButtons.MIDDLE=THREE.MOUSE.PAN;});
    window.addEventListener('keyup',  e=>{if(e.key==='Shift')controls.mouseButtons.MIDDLE=THREE.MOUSE.ROTATE;});
    const transformControls=new TransformControls(camera,renderer.domElement);
    transformControls.setTranslationSnap(0.1);
    transformControls.setRotationSnap(THREE.MathUtils.degToRad(15));
    transformControls.addEventListener('dragging-changed',e=>controls.enabled=!e.value);
    scene.add(transformControls);

    // State
    const raycaster=new THREE.Raycaster(), pointer=new THREE.Vector2();
    const groundPlane=new THREE.Plane(new THREE.Vector3(0,1,0),0);
    let mode='draw', isDragging=false, previewMesh=null;
    let startPt=new THREE.Vector3();
    const objects=[];
    const material=new THREE.MeshNormalMaterial({side:THREE.DoubleSide});
    let loadedModel=null, selectionOutline=null;

    // UI refs
    const uiContainer=document.getElementById('ui-container');
    const modeSelect=document.getElementById('modeSelect');
    const drawUI=document.getElementById('draw-ui');
    const editUI=document.getElementById('edit-ui');
    const importUI=document.getElementById('import-ui');
    const transformModeSelect=document.getElementById('transformMode');
    const uploadBtn=document.getElementById('uploadModel');
    const fileInput=document.getElementById('modelInput');
    const uploadStatus=document.getElementById('uploadStatus');
    const exportBtn=document.getElementById('exportScene');
    const snapBtn=document.getElementById('snapFloor');
    const addFloorBtn=document.getElementById('addFloor');
    const addWallBtn=document.getElementById('addWall');
    const addWallBtn2=document.getElementById('addWallThick');
    const objectList=document.getElementById('objectList');

    // Visibility UI
    function updateVisibilityUI(){objectList.innerHTML='';objects.forEach(obj=>{const div=document.createElement('div');const cb=document.createElement('input');cb.type='checkbox';cb.checked=obj.visible;cb.addEventListener('change',()=>obj.visible=cb.checked);const span=document.createElement('span');span.textContent=obj.name;span.style.flex='1';span.style.cursor='pointer';span.addEventListener('dblclick',()=>{const inp=document.createElement('input');inp.type='text';inp.value=obj.name;inp.style.flex='1';inp.addEventListener('blur',()=>{obj.name=inp.value||obj.name;updateVisibilityUI();});inp.addEventListener('keydown',e=>{if(e.key==='Enter')inp.blur();});div.replaceChild(inp,span);inp.focus();});div.append(cb,span);objectList.append(div);});}

    // Mode change
    modeSelect.addEventListener('change',()=>{
      mode=modeSelect.value; transformControls.detach();
      drawUI.style.display=(mode==='draw')?'block':'none';
      editUI.style.display=(mode==='edit')?'block':'none';
      importUI.style.display=(mode==='draw')?'block':'none';
      if(importUI.style.display==='block') importUI.style.top=`${uiContainer.offsetTop+uiContainer.offsetHeight+10}px`;
      uploadBtn.style.display=(mode==='import')?'block':'none';
      snapBtn.style.display=(mode==='edit')?'inline-block':'none';
    });
    modeSelect.dispatchEvent(new Event('change'));

    // Transform mode
    transformModeSelect.addEventListener('change',()=>{
      transformControls.setMode(transformModeSelect.value);
    });

    // Upload model
    uploadBtn.addEventListener('click',()=>fileInput.click());
    fileInput.addEventListener('change',e=>{const file=e.target.files[0];if(!file)return;const url=URL.createObjectURL(file);const loader=file.name.endsWith('.obj')?new OBJLoader():new GLTFLoader();loader.load(url,gltf=>{loadedModel=gltf.scene||gltf;uploadStatus.textContent=file.name;});});

    // Export
    exportBtn.addEventListener('click',()=>{const exporter=new OBJExporter();const data=exporter.parse(scene);const blob=new Blob([data],{type:'text/plain'});const a=document.createElement('a');a.href=URL.createObjectURL(blob);a.download='scene.obj';a.click();URL.revokeObjectURL(a.href);});

    // Helpers
    function getPointer(e){const rect=renderer.domElement.getBoundingClientRect();pointer.x=((e.clientX-rect.left)/rect.width)*2-1;pointer.y=-((e.clientY-rect.top)/rect.height)*2+1;}
    function intersectGround(){const pt=new THREE.Vector3();raycaster.ray.intersectPlane(groundPlane,pt);return pt;}

    // Interaction
    renderer.domElement.addEventListener('pointerdown',e=>{
      getPointer(e); raycaster.setFromCamera(pointer,camera); if(e.button!==0)return;
      if(mode==='draw'){
        const pt=intersectGround(); if(!pt)return; isDragging=true; startPt.copy(pt); controls.enabled=false;
      } else if(mode==='import'&&loadedModel){
        const pt=intersectGround(); if(!pt)return; const clone=loadedModel.clone(); clone.position.copy(pt); scene.add(clone); objects.push(clone); updateVisibilityUI();
      } else if(mode==='edit'){
        const hits=raycaster.intersectObjects(objects,true);
        if(hits.length){
          if(selectionOutline){scene.remove(selectionOutline);selectionOutline=null;}
          const obj=hits[0].object;
          transformControls.attach(obj); transformControls.setMode(transformModeSelect.value);
          const edgeGeo=new THREE.EdgesGeometry(obj.geometry);
          selectionOutline=new THREE.LineSegments(edgeGeo,new THREE.LineBasicMaterial({color:0xffff00,linewidth:3}));
          selectionOutline.position.copy(obj.position);
          selectionOutline.rotation.copy(obj.rotation);
          selectionOutline.scale.copy(obj.scale);
          scene.add(selectionOutline);
        } else {
          transformControls.detach();
          if(selectionOutline){scene.remove(selectionOutline);selectionOutline=null;}
        }
      } else {
        transformControls.detach();
      }
    });

    renderer.domElement.addEventListener('pointermove',e=>{if(!isDragging)return;getPointer(e);raycaster.setFromCamera(pointer,camera);const pt=intersectGround();if(!pt)return;const dx=pt.x-startPt.x,dz=pt.z-startPt.z;const sx=Math.abs(dx)||0.01,sz=Math.abs(dz)||0.01;const h=parseFloat(document.getElementById('height').value)||1;const cx=startPt.x+dx/2,cy=h/2,cz=startPt.z+dz/2; if(previewMesh){scene.remove(previewMesh);previewMesh.geometry.dispose();previewMesh.material.dispose();}previewMesh=new THREE.Mesh(new THREE.BoxGeometry(sx,h,sz),material);previewMesh.position.set(cx,cy,cz);scene.add(previewMesh);});

    window.addEventListener('pointerup',e=>{if(e.button===0&&isDragging){isDragging=false;controls.enabled=true; if(previewMesh){const mesh=new THREE.Mesh(previewMesh.geometry.clone(),material.clone());mesh.position.copy(previewMesh.position);mesh.castShadow=true;mesh.receiveShadow=true;mesh.name=`Box ${objects.length+1}`;scene.add(mesh);objects.push(mesh);scene.remove(previewMesh);previewMesh=null;updateVisibilityUI();}}});

    // Add floor/wall
    document.getElementById('addFloor').addEventListener('click',()=>{const thickness=0.25;const floor=new THREE.Mesh(new THREE.BoxGeometry(10,thickness,10),material);floor.position.set(0,thickness/2,0);floor.name='Floor';scene.add(floor);objects.push(floor);updateVisibilityUI();});
    document.getElementById('addWall').addEventListener('click',()=>{const thickness=0.1;const wall=new THREE.Mesh(new THREE.BoxGeometry(10,8,thickness),material);wall.position.set(0,4,-thickness/2);wall.name='Wall';scene.add(wall);objects.push(wall);updateVisibilityUI();});
    document.getElementById('addWallThick').addEventListener('click',()=>{const thickness=0.5;const wall=new THREE.Mesh(new THREE.BoxGeometry(10,8,thickness),material);wall.position.set(0,4,-thickness/2);wall.name='Wall';scene.add(wall);objects.push(wall);updateVisibilityUI();});

    // Return to Floor
    snapBtn.addEventListener('click',()=>{const sel=transformControls.object;if(sel){const box=new THREE.Box3().setFromObject(sel);const minY=box.min.y;sel.position.y-=minY;}});

    // Delete
    window.addEventListener('keydown',e=>{if(mode==='edit'&&(e.key==='Delete'||e.key==='Backspace')){const sel=transformControls.object;if(sel){scene.remove(sel);const idx=objects.indexOf(sel);if(idx>-1)objects.splice(idx,1);transformControls.detach();updateVisibilityUI();}}});

    // Resize & animate
    window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);});
    (function animate(){requestAnimationFrame(animate);controls.update();renderer.render(scene,camera);})();
  </script>
</body>
</html>
